#!/bin/bash
# oci-config-export - Export OCI Terraform configuration to vault
#
# This script:
# 1. Parses terraform.tfvars to extract variable values
# 2. Parses _backend.tf to extract OCI backend configuration (namespace)
# 3. Creates or updates a vault item with the configuration
#
# Usage: oci-config-export [options] [terraform_dir]
#
# Examples:
#   oci-config-export terraform/config     # Export config tfvars to vault
#   oci-config-export terraform/infra      # Export infra tfvars to vault
#   oci-config-export --domain example.com # Specify domain explicitly

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOADER_ROOT="$(dirname "$SCRIPT_DIR")"

# Source libraries
source "$LOADER_ROOT/lib/common.sh"
source "$LOADER_ROOT/lib/vault-providers/_interface.sh"

# ============================================================================
# HELP
# ============================================================================

show_help() {
    cat << EOF
Usage: oci-config-export [options] [terraform_dir]

Export OCI Terraform configuration to vault provider (Bitwarden/1Password).

The script reads terraform.tfvars and _backend.tf and creates or updates
a vault item with the configuration values.

Options:
  --domain DOMAIN   Domain for the vault item (e.g., example.com)
  --dry-run         Show what would be done without making changes
  --verbose         Enable verbose output for debugging
  --create          Create new item (fail if exists)
  --update          Update existing item (fail if not exists)
  --help            Show this help message

Arguments:
  terraform_dir     Path to Terraform directory (default: current directory)

Examples:
  oci-config-export terraform/config          # Export config to vault
  oci-config-export terraform/infra           # Export infra to vault
  oci-config-export --domain example.com .    # Use specific domain

Supported vault providers:
  - BitWarden (bw)
  - 1Password (op)

EOF
    exit 0
}

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

DOMAIN=""
TERRAFORM_DIR=""
CREATE_ONLY=false
UPDATE_ONLY=false

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --domain)
                DOMAIN="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --create)
                CREATE_ONLY=true
                shift
                ;;
            --update)
                UPDATE_ONLY=true
                shift
                ;;
            --help|-h)
                show_help
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
            *)
                TERRAFORM_DIR="$1"
                shift
                ;;
        esac
    done

    # Default to current directory
    if [[ -z "$TERRAFORM_DIR" ]]; then
        TERRAFORM_DIR="."
    fi

    # Resolve to absolute path
    TERRAFORM_DIR="$(cd "$TERRAFORM_DIR" 2>/dev/null && pwd)" || {
        log_error "Directory not found: $TERRAFORM_DIR"
        exit 1
    }
}

# ============================================================================
# TFVARS PARSING
# ============================================================================

# Parse terraform.tfvars and extract variable values
# Sets CONFIG_* variables for each tfvar
# Supports: simple values, heredocs, maps, lists, and nested structures
parse_tfvars() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        return 1
    fi

    log_verbose "Parsing: $file"

    # State tracking
    local current_var=""
    local in_heredoc=false
    local heredoc_marker=""
    local heredoc_value=""
    local in_complex=false
    local complex_value=""
    local brace_depth=0
    local bracket_depth=0

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments (but not inside heredocs or complex types)
        if ! $in_heredoc && ! $in_complex; then
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
        fi

        # Handle heredoc content
        if $in_heredoc; then
            if [[ "$line" == "$heredoc_marker" ]]; then
                # End of heredoc
                local var_upper
                var_upper=$(echo "$current_var" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
                export "CONFIG_$var_upper=$heredoc_value"
                log_verbose "Parsed (heredoc): $current_var"
                in_heredoc=false
                heredoc_value=""
            else
                heredoc_value+="$line"$'\n'
            fi
            continue
        fi

        # Handle complex type content (maps, lists, objects)
        if $in_complex; then
            complex_value+="$line"$'\n'

            # Count braces and brackets
            local open_braces="${line//[^\{]/}"
            local close_braces="${line//[^\}]/}"
            local open_brackets="${line//[^\[]/}"
            local close_brackets="${line//[^\]]/}"

            brace_depth=$((brace_depth + ${#open_braces} - ${#close_braces}))
            bracket_depth=$((bracket_depth + ${#open_brackets} - ${#close_brackets}))

            # Check if complex type is complete
            if [[ $brace_depth -eq 0 && $bracket_depth -eq 0 ]]; then
                local var_upper
                var_upper=$(echo "$current_var" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
                # Remove trailing newline and store
                complex_value="${complex_value%$'\n'}"
                export "CONFIG_$var_upper=$complex_value"
                log_verbose "Parsed (complex): $current_var"
                in_complex=false
                complex_value=""
            fi
            continue
        fi

        # Check for heredoc start
        if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*\<\<-?([A-Z]+) ]]; then
            current_var="${BASH_REMATCH[1]}"
            heredoc_marker="${BASH_REMATCH[2]}"
            in_heredoc=true
            heredoc_value=""
            continue
        fi

        # Check for complex type start (map or list)
        if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(\{|\[) ]]; then
            current_var="${BASH_REMATCH[1]}"
            local start_char="${BASH_REMATCH[2]}"

            # Get the rest of the line after the variable name
            local rest="${line#*=}"
            rest="${rest#"${rest%%[![:space:]]*}"}"  # Trim leading whitespace

            # Count initial depth
            local open_braces="${rest//[^\{]/}"
            local close_braces="${rest//[^\}]/}"
            local open_brackets="${rest//[^\[]/}"
            local close_brackets="${rest//[^\]]/}"

            brace_depth=$((${#open_braces} - ${#close_braces}))
            bracket_depth=$((${#open_brackets} - ${#close_brackets}))

            # Check if it's a single-line complex type
            if [[ $brace_depth -eq 0 && $bracket_depth -eq 0 ]]; then
                local var_upper
                var_upper=$(echo "$current_var" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
                export "CONFIG_$var_upper=$rest"
                log_verbose "Parsed (inline complex): $current_var"
            else
                # Multi-line complex type
                in_complex=true
                complex_value="$rest"$'\n'
            fi
            continue
        fi

        # Simple key = "value" or key = value
        if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(.+) ]]; then
            local var_name="${BASH_REMATCH[1]}"
            local var_value="${BASH_REMATCH[2]}"

            # Remove quotes if present (for simple string values)
            if [[ "$var_value" =~ ^\".*\"$ ]]; then
                var_value="${var_value#\"}"
                var_value="${var_value%\"}"
            fi

            # Convert to CONFIG_* format
            local var_upper
            var_upper=$(echo "$var_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
            export "CONFIG_$var_upper=$var_value"
            log_verbose "Parsed: $var_name = ${var_value:0:30}..."
        fi
    done < "$file"
}

# Parse _backend.tf to extract OCI backend configuration
parse_backend_tf() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        log_verbose "Backend file not found: $file"
        return 0
    fi

    log_verbose "Parsing backend: $file"

    # Extract namespace from backend block
    local namespace
    namespace=$(grep -E '^\s*namespace\s*=' "$file" | sed -E 's/.*=\s*"([^"]+)".*/\1/' | head -1)
    if [[ -n "$namespace" ]]; then
        export CONFIG_OCI_NAMESPACE="$namespace"
        log_verbose "Parsed backend: oci_namespace = $namespace"
    fi

    # Extract bucket (for reference)
    local bucket
    bucket=$(grep -E '^\s*bucket\s*=' "$file" | sed -E 's/.*=\s*"([^"]+)".*/\1/' | head -1)
    if [[ -n "$bucket" ]]; then
        export CONFIG_OCI_BUCKET="$bucket"
        log_verbose "Parsed backend: oci_bucket = $bucket"
    fi

    # Extract config_file_profile
    local profile
    profile=$(grep -E '^\s*config_file_profile\s*=' "$file" | sed -E 's/.*=\s*"([^"]+)".*/\1/' | head -1)
    if [[ -n "$profile" ]]; then
        export CONFIG_OCI_PROFILE="$profile"
        log_verbose "Parsed backend: oci_profile = $profile"
    fi
}

# ============================================================================
# PROVIDER SELECTION
# ============================================================================

select_provider() {
    local available
    available=$(detect_available_providers)

    if [[ -z "$available" ]]; then
        log_error "No vault providers installed!"
        show_all_provider_instructions
        exit 1
    fi

    local provider_count
    provider_count=$(echo "$available" | wc -w)

    if [[ $provider_count -eq 1 ]]; then
        echo "$available"
        return
    fi

    echo "Available vault providers:" >&2
    local i=1
    local providers=($available)
    for p in "${providers[@]}"; do
        echo "  $i) $p" >&2
        ((i++))
    done

    read -p "Select provider [1]: " choice
    choice=${choice:-1}

    if [[ $choice -lt 1 || $choice -gt ${#providers[@]} ]]; then
        log_error "Invalid selection"
        exit 1
    fi

    echo "${providers[$((choice-1))]}"
}

# ============================================================================
# MAIN LOGIC
# ============================================================================

main() {
    parse_args "$@"

    log_info "oci-config-export - Export OCI Terraform configuration to vault"
    log_verbose "Terraform directory: $TERRAFORM_DIR"

    # Check requirements
    check_requirements || exit 1

    # Find terraform.tfvars
    local tfvars_file="$TERRAFORM_DIR/terraform.tfvars"
    if [[ ! -f "$tfvars_file" ]]; then
        log_error "No terraform.tfvars found in $TERRAFORM_DIR"
        exit 1
    fi

    # Parse tfvars
    log_step "Parsing $tfvars_file..."
    parse_tfvars "$tfvars_file"

    # Parse backend file if exists
    local backend_file="$TERRAFORM_DIR/_backend.tf"
    if [[ -f "$backend_file" ]]; then
        log_step "Parsing $backend_file..."
        parse_backend_tf "$backend_file"
    fi

    # Get domain from tfvars or argument
    if [[ -z "$DOMAIN" ]]; then
        DOMAIN="${CONFIG_DOMAIN:-}"
    fi

    if [[ -z "$DOMAIN" ]]; then
        log_error "Domain not specified. Use --domain or set 'domain' in terraform.tfvars"
        exit 1
    fi

    log_info "Exporting configuration for: $DOMAIN"

    # Select and load provider
    log_step "Detecting vault providers..."
    local provider
    provider=$(select_provider)
    log_info "Using provider: $provider"

    load_provider "$provider" || {
        log_error "Failed to load provider: $provider"
        exit 1
    }

    # Login to vault
    provider_login || {
        log_error "Failed to login to vault"
        exit 1
    }

    # Sync vault
    provider_sync

    # Build fields JSON from parsed CONFIG_* variables
    log_step "Building configuration..."
    local fields_json="[]"
    local field_count=0

    # Iterate through all CONFIG_* environment variables
    while IFS='=' read -r name value; do
        # Skip if empty
        [[ -z "$value" ]] && continue

        # Convert CONFIG_VAR_NAME to var_name
        local var_name="${name#CONFIG_}"
        var_name=$(echo "$var_name" | tr '[:upper:]' '[:lower:]')

        # Determine if this is a sensitive field (type: 1 = hidden)
        local field_type=0
        if is_sensitive_var "$var_name"; then
            field_type=1
        fi

        # Add to fields array
        fields_json=$(echo "$fields_json" | jq \
            --arg name "$var_name" \
            --arg value "$value" \
            --argjson type "$field_type" \
            '. + [{name: $name, value: $value, type: $type}]')
        field_count=$((field_count + 1))
    done < <(env | grep "^CONFIG_" | sort)

    log_info "Fields to export: $field_count"

    # Check if item exists
    local item_name="OCI Terraform - $DOMAIN"
    local existing_item
    existing_item=$(provider_get_item "$item_name" 2>/dev/null || echo "")

    if $DRY_RUN; then
        if [[ -n "$existing_item" && "$existing_item" != "null" ]]; then
            log_dry_run "Update existing item: $item_name"
        else
            log_dry_run "Create new item: $item_name"
        fi
        log_dry_run "Export $field_count fields"
        exit 0
    fi

    if [[ -n "$existing_item" && "$existing_item" != "null" ]]; then
        if $CREATE_ONLY; then
            log_error "Item already exists: $item_name"
            log_info "Use --update to update existing item"
            exit 1
        fi

        # Update existing item
        log_step "Updating existing item: $item_name"
        local item_id
        item_id=$(provider_get_item_id "$existing_item")
        provider_update_item "$item_id" "$item_name" "$fields_json" > /dev/null
        log_info "Item updated successfully"
    else
        if $UPDATE_ONLY; then
            log_error "Item not found: $item_name"
            log_info "Use --create to create new item"
            exit 1
        fi

        # Create new item
        log_step "Creating new item: $item_name"
        provider_create_item "$item_name" "$fields_json" > /dev/null
        log_info "Item created successfully"
    fi

    # Sync to ensure changes are propagated
    provider_sync

    log_info "Export complete: $item_name"
}

main "$@"
